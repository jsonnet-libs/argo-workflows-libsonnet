{
  local d = (import 'doc-util/main.libsonnet'),
  '#':: d.pkg(name='artifactNodeSpec', url='', help='"ArtifactNodeSpec specifies the Artifacts that need to be deleted for a given Node"'),
  '#archiveLocation':: d.obj(help='"ArtifactLocation describes a location for a single or multiple artifacts. It is used as single artifact in the context of inputs/outputs (e.g. outputs.artifacts.artname). It is also used to describe the location of multiple artifacts such as the archive location of a single workflow step, which the executor will use as a default location to store its files."'),
  archiveLocation: {
    '#artifactory':: d.obj(help='"ArtifactoryArtifact is the location of an artifactory artifact"'),
    artifactory: {
      '#passwordSecret':: d.obj(help='"SecretKeySelector selects a key of a Secret."'),
      passwordSecret: {
        '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
        withKey(key): { archiveLocation+: { artifactory+: { passwordSecret+: { key: key } } } },
        '#withName':: d.fn(help='"Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
        withName(name): { archiveLocation+: { artifactory+: { passwordSecret+: { name: name } } } },
        '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
        withOptional(optional): { archiveLocation+: { artifactory+: { passwordSecret+: { optional: optional } } } },
      },
      '#usernameSecret':: d.obj(help='"SecretKeySelector selects a key of a Secret."'),
      usernameSecret: {
        '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
        withKey(key): { archiveLocation+: { artifactory+: { usernameSecret+: { key: key } } } },
        '#withName':: d.fn(help='"Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
        withName(name): { archiveLocation+: { artifactory+: { usernameSecret+: { name: name } } } },
        '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
        withOptional(optional): { archiveLocation+: { artifactory+: { usernameSecret+: { optional: optional } } } },
      },
      '#withUrl':: d.fn(help='"URL of the artifact"', args=[d.arg(name='url', type=d.T.string)]),
      withUrl(url): { archiveLocation+: { artifactory+: { url: url } } },
    },
    '#azure':: d.obj(help='"AzureArtifact is the location of a an Azure Storage artifact"'),
    azure: {
      '#accountKeySecret':: d.obj(help='"SecretKeySelector selects a key of a Secret."'),
      accountKeySecret: {
        '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
        withKey(key): { archiveLocation+: { azure+: { accountKeySecret+: { key: key } } } },
        '#withName':: d.fn(help='"Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
        withName(name): { archiveLocation+: { azure+: { accountKeySecret+: { name: name } } } },
        '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
        withOptional(optional): { archiveLocation+: { azure+: { accountKeySecret+: { optional: optional } } } },
      },
      '#withBlob':: d.fn(help='"Blob is the blob name (i.e., path) in the container where the artifact resides"', args=[d.arg(name='blob', type=d.T.string)]),
      withBlob(blob): { archiveLocation+: { azure+: { blob: blob } } },
      '#withContainer':: d.fn(help='"Container is the container where resources will be stored"', args=[d.arg(name='container', type=d.T.string)]),
      withContainer(container): { archiveLocation+: { azure+: { container: container } } },
      '#withEndpoint':: d.fn(help='"Endpoint is the service url associated with an account. It is most likely \\"https://<ACCOUNT_NAME>.blob.core.windows.net\\', args=[d.arg(name='endpoint', type=d.T.string)]),
      withEndpoint(endpoint): { archiveLocation+: { azure+: { endpoint: endpoint } } },
      '#withUseSDKCreds':: d.fn(help='"UseSDKCreds tells the driver to figure out credentials based on sdk defaults."', args=[d.arg(name='useSDKCreds', type=d.T.boolean)]),
      withUseSDKCreds(useSDKCreds): { archiveLocation+: { azure+: { useSDKCreds: useSDKCreds } } },
    },
    '#gcs':: d.obj(help='"GCSArtifact is the location of a GCS artifact"'),
    gcs: {
      '#serviceAccountKeySecret':: d.obj(help='"SecretKeySelector selects a key of a Secret."'),
      serviceAccountKeySecret: {
        '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
        withKey(key): { archiveLocation+: { gcs+: { serviceAccountKeySecret+: { key: key } } } },
        '#withName':: d.fn(help='"Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
        withName(name): { archiveLocation+: { gcs+: { serviceAccountKeySecret+: { name: name } } } },
        '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
        withOptional(optional): { archiveLocation+: { gcs+: { serviceAccountKeySecret+: { optional: optional } } } },
      },
      '#withBucket':: d.fn(help='"Bucket is the name of the bucket"', args=[d.arg(name='bucket', type=d.T.string)]),
      withBucket(bucket): { archiveLocation+: { gcs+: { bucket: bucket } } },
      '#withKey':: d.fn(help='"Key is the path in the bucket where the artifact resides"', args=[d.arg(name='key', type=d.T.string)]),
      withKey(key): { archiveLocation+: { gcs+: { key: key } } },
    },
    '#git':: d.obj(help='"GitArtifact is the location of an git artifact"'),
    git: {
      '#passwordSecret':: d.obj(help='"SecretKeySelector selects a key of a Secret."'),
      passwordSecret: {
        '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
        withKey(key): { archiveLocation+: { git+: { passwordSecret+: { key: key } } } },
        '#withName':: d.fn(help='"Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
        withName(name): { archiveLocation+: { git+: { passwordSecret+: { name: name } } } },
        '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
        withOptional(optional): { archiveLocation+: { git+: { passwordSecret+: { optional: optional } } } },
      },
      '#sshPrivateKeySecret':: d.obj(help='"SecretKeySelector selects a key of a Secret."'),
      sshPrivateKeySecret: {
        '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
        withKey(key): { archiveLocation+: { git+: { sshPrivateKeySecret+: { key: key } } } },
        '#withName':: d.fn(help='"Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
        withName(name): { archiveLocation+: { git+: { sshPrivateKeySecret+: { name: name } } } },
        '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
        withOptional(optional): { archiveLocation+: { git+: { sshPrivateKeySecret+: { optional: optional } } } },
      },
      '#usernameSecret':: d.obj(help='"SecretKeySelector selects a key of a Secret."'),
      usernameSecret: {
        '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
        withKey(key): { archiveLocation+: { git+: { usernameSecret+: { key: key } } } },
        '#withName':: d.fn(help='"Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
        withName(name): { archiveLocation+: { git+: { usernameSecret+: { name: name } } } },
        '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
        withOptional(optional): { archiveLocation+: { git+: { usernameSecret+: { optional: optional } } } },
      },
      '#withBranch':: d.fn(help='"Branch is the branch to fetch when `SingleBranch` is enabled"', args=[d.arg(name='branch', type=d.T.string)]),
      withBranch(branch): { archiveLocation+: { git+: { branch: branch } } },
      '#withDepth':: d.fn(help='"Depth specifies clones/fetches should be shallow and include the given number of commits from the branch tip"', args=[d.arg(name='depth', type=d.T.integer)]),
      withDepth(depth): { archiveLocation+: { git+: { depth: depth } } },
      '#withDisableSubmodules':: d.fn(help='"DisableSubmodules disables submodules during git clone"', args=[d.arg(name='disableSubmodules', type=d.T.boolean)]),
      withDisableSubmodules(disableSubmodules): { archiveLocation+: { git+: { disableSubmodules: disableSubmodules } } },
      '#withFetch':: d.fn(help='"Fetch specifies a number of refs that should be fetched before checkout"', args=[d.arg(name='fetch', type=d.T.array)]),
      withFetch(fetch): { archiveLocation+: { git+: { fetch: if std.isArray(v=fetch) then fetch else [fetch] } } },
      '#withFetchMixin':: d.fn(help='"Fetch specifies a number of refs that should be fetched before checkout"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='fetch', type=d.T.array)]),
      withFetchMixin(fetch): { archiveLocation+: { git+: { fetch+: if std.isArray(v=fetch) then fetch else [fetch] } } },
      '#withInsecureIgnoreHostKey':: d.fn(help='"InsecureIgnoreHostKey disables SSH strict host key checking during git clone"', args=[d.arg(name='insecureIgnoreHostKey', type=d.T.boolean)]),
      withInsecureIgnoreHostKey(insecureIgnoreHostKey): { archiveLocation+: { git+: { insecureIgnoreHostKey: insecureIgnoreHostKey } } },
      '#withRepo':: d.fn(help='"Repo is the git repository"', args=[d.arg(name='repo', type=d.T.string)]),
      withRepo(repo): { archiveLocation+: { git+: { repo: repo } } },
      '#withRevision':: d.fn(help='"Revision is the git commit, tag, branch to checkout"', args=[d.arg(name='revision', type=d.T.string)]),
      withRevision(revision): { archiveLocation+: { git+: { revision: revision } } },
      '#withSingleBranch':: d.fn(help='"SingleBranch enables single branch clone, using the `branch` parameter"', args=[d.arg(name='singleBranch', type=d.T.boolean)]),
      withSingleBranch(singleBranch): { archiveLocation+: { git+: { singleBranch: singleBranch } } },
    },
    '#hdfs':: d.obj(help='"HDFSArtifact is the location of an HDFS artifact"'),
    hdfs: {
      '#krbCCacheSecret':: d.obj(help='"SecretKeySelector selects a key of a Secret."'),
      krbCCacheSecret: {
        '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
        withKey(key): { archiveLocation+: { hdfs+: { krbCCacheSecret+: { key: key } } } },
        '#withName':: d.fn(help='"Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
        withName(name): { archiveLocation+: { hdfs+: { krbCCacheSecret+: { name: name } } } },
        '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
        withOptional(optional): { archiveLocation+: { hdfs+: { krbCCacheSecret+: { optional: optional } } } },
      },
      '#krbConfigConfigMap':: d.obj(help='"Selects a key from a ConfigMap."'),
      krbConfigConfigMap: {
        '#withKey':: d.fn(help='"The key to select."', args=[d.arg(name='key', type=d.T.string)]),
        withKey(key): { archiveLocation+: { hdfs+: { krbConfigConfigMap+: { key: key } } } },
        '#withName':: d.fn(help='"Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
        withName(name): { archiveLocation+: { hdfs+: { krbConfigConfigMap+: { name: name } } } },
        '#withOptional':: d.fn(help='"Specify whether the ConfigMap or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
        withOptional(optional): { archiveLocation+: { hdfs+: { krbConfigConfigMap+: { optional: optional } } } },
      },
      '#krbKeytabSecret':: d.obj(help='"SecretKeySelector selects a key of a Secret."'),
      krbKeytabSecret: {
        '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
        withKey(key): { archiveLocation+: { hdfs+: { krbKeytabSecret+: { key: key } } } },
        '#withName':: d.fn(help='"Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
        withName(name): { archiveLocation+: { hdfs+: { krbKeytabSecret+: { name: name } } } },
        '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
        withOptional(optional): { archiveLocation+: { hdfs+: { krbKeytabSecret+: { optional: optional } } } },
      },
      '#withAddresses':: d.fn(help='"Addresses is accessible addresses of HDFS name nodes"', args=[d.arg(name='addresses', type=d.T.array)]),
      withAddresses(addresses): { archiveLocation+: { hdfs+: { addresses: if std.isArray(v=addresses) then addresses else [addresses] } } },
      '#withAddressesMixin':: d.fn(help='"Addresses is accessible addresses of HDFS name nodes"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='addresses', type=d.T.array)]),
      withAddressesMixin(addresses): { archiveLocation+: { hdfs+: { addresses+: if std.isArray(v=addresses) then addresses else [addresses] } } },
      '#withForce':: d.fn(help='"Force copies a file forcibly even if it exists"', args=[d.arg(name='force', type=d.T.boolean)]),
      withForce(force): { archiveLocation+: { hdfs+: { force: force } } },
      '#withHdfsUser':: d.fn(help='"HDFSUser is the user to access HDFS file system. It is ignored if either ccache or keytab is used."', args=[d.arg(name='hdfsUser', type=d.T.string)]),
      withHdfsUser(hdfsUser): { archiveLocation+: { hdfs+: { hdfsUser: hdfsUser } } },
      '#withKrbRealm':: d.fn(help='"KrbRealm is the Kerberos realm used with Kerberos keytab It must be set if keytab is used."', args=[d.arg(name='krbRealm', type=d.T.string)]),
      withKrbRealm(krbRealm): { archiveLocation+: { hdfs+: { krbRealm: krbRealm } } },
      '#withKrbServicePrincipalName':: d.fn(help='"KrbServicePrincipalName is the principal name of Kerberos service It must be set if either ccache or keytab is used."', args=[d.arg(name='krbServicePrincipalName', type=d.T.string)]),
      withKrbServicePrincipalName(krbServicePrincipalName): { archiveLocation+: { hdfs+: { krbServicePrincipalName: krbServicePrincipalName } } },
      '#withKrbUsername':: d.fn(help='"KrbUsername is the Kerberos username used with Kerberos keytab It must be set if keytab is used."', args=[d.arg(name='krbUsername', type=d.T.string)]),
      withKrbUsername(krbUsername): { archiveLocation+: { hdfs+: { krbUsername: krbUsername } } },
      '#withPath':: d.fn(help='"Path is a file path in HDFS"', args=[d.arg(name='path', type=d.T.string)]),
      withPath(path): { archiveLocation+: { hdfs+: { path: path } } },
    },
    '#http':: d.obj(help='"HTTPArtifact allows a file served on HTTP to be placed as an input artifact in a container"'),
    http: {
      '#auth':: d.obj(help=''),
      auth: {
        '#basicAuth':: d.obj(help='"BasicAuth describes the secret selectors required for basic authentication"'),
        basicAuth: {
          '#passwordSecret':: d.obj(help='"SecretKeySelector selects a key of a Secret."'),
          passwordSecret: {
            '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
            withKey(key): { archiveLocation+: { http+: { auth+: { basicAuth+: { passwordSecret+: { key: key } } } } } },
            '#withName':: d.fn(help='"Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { archiveLocation+: { http+: { auth+: { basicAuth+: { passwordSecret+: { name: name } } } } } },
            '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
            withOptional(optional): { archiveLocation+: { http+: { auth+: { basicAuth+: { passwordSecret+: { optional: optional } } } } } },
          },
          '#usernameSecret':: d.obj(help='"SecretKeySelector selects a key of a Secret."'),
          usernameSecret: {
            '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
            withKey(key): { archiveLocation+: { http+: { auth+: { basicAuth+: { usernameSecret+: { key: key } } } } } },
            '#withName':: d.fn(help='"Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { archiveLocation+: { http+: { auth+: { basicAuth+: { usernameSecret+: { name: name } } } } } },
            '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
            withOptional(optional): { archiveLocation+: { http+: { auth+: { basicAuth+: { usernameSecret+: { optional: optional } } } } } },
          },
        },
        '#clientCert':: d.obj(help='"ClientCertAuth holds necessary information for client authentication via certificates"'),
        clientCert: {
          '#clientCertSecret':: d.obj(help='"SecretKeySelector selects a key of a Secret."'),
          clientCertSecret: {
            '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
            withKey(key): { archiveLocation+: { http+: { auth+: { clientCert+: { clientCertSecret+: { key: key } } } } } },
            '#withName':: d.fn(help='"Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { archiveLocation+: { http+: { auth+: { clientCert+: { clientCertSecret+: { name: name } } } } } },
            '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
            withOptional(optional): { archiveLocation+: { http+: { auth+: { clientCert+: { clientCertSecret+: { optional: optional } } } } } },
          },
          '#clientKeySecret':: d.obj(help='"SecretKeySelector selects a key of a Secret."'),
          clientKeySecret: {
            '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
            withKey(key): { archiveLocation+: { http+: { auth+: { clientCert+: { clientKeySecret+: { key: key } } } } } },
            '#withName':: d.fn(help='"Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { archiveLocation+: { http+: { auth+: { clientCert+: { clientKeySecret+: { name: name } } } } } },
            '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
            withOptional(optional): { archiveLocation+: { http+: { auth+: { clientCert+: { clientKeySecret+: { optional: optional } } } } } },
          },
        },
        '#oauth2':: d.obj(help='"OAuth2Auth holds all information for client authentication via OAuth2 tokens"'),
        oauth2: {
          '#clientIDSecret':: d.obj(help='"SecretKeySelector selects a key of a Secret."'),
          clientIDSecret: {
            '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
            withKey(key): { archiveLocation+: { http+: { auth+: { oauth2+: { clientIDSecret+: { key: key } } } } } },
            '#withName':: d.fn(help='"Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { archiveLocation+: { http+: { auth+: { oauth2+: { clientIDSecret+: { name: name } } } } } },
            '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
            withOptional(optional): { archiveLocation+: { http+: { auth+: { oauth2+: { clientIDSecret+: { optional: optional } } } } } },
          },
          '#clientSecretSecret':: d.obj(help='"SecretKeySelector selects a key of a Secret."'),
          clientSecretSecret: {
            '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
            withKey(key): { archiveLocation+: { http+: { auth+: { oauth2+: { clientSecretSecret+: { key: key } } } } } },
            '#withName':: d.fn(help='"Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { archiveLocation+: { http+: { auth+: { oauth2+: { clientSecretSecret+: { name: name } } } } } },
            '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
            withOptional(optional): { archiveLocation+: { http+: { auth+: { oauth2+: { clientSecretSecret+: { optional: optional } } } } } },
          },
          '#tokenURLSecret':: d.obj(help='"SecretKeySelector selects a key of a Secret."'),
          tokenURLSecret: {
            '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
            withKey(key): { archiveLocation+: { http+: { auth+: { oauth2+: { tokenURLSecret+: { key: key } } } } } },
            '#withName':: d.fn(help='"Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
            withName(name): { archiveLocation+: { http+: { auth+: { oauth2+: { tokenURLSecret+: { name: name } } } } } },
            '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
            withOptional(optional): { archiveLocation+: { http+: { auth+: { oauth2+: { tokenURLSecret+: { optional: optional } } } } } },
          },
          '#withEndpointParams':: d.fn(help='', args=[d.arg(name='endpointParams', type=d.T.array)]),
          withEndpointParams(endpointParams): { archiveLocation+: { http+: { auth+: { oauth2+: { endpointParams: if std.isArray(v=endpointParams) then endpointParams else [endpointParams] } } } } },
          '#withEndpointParamsMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='endpointParams', type=d.T.array)]),
          withEndpointParamsMixin(endpointParams): { archiveLocation+: { http+: { auth+: { oauth2+: { endpointParams+: if std.isArray(v=endpointParams) then endpointParams else [endpointParams] } } } } },
          '#withScopes':: d.fn(help='', args=[d.arg(name='scopes', type=d.T.array)]),
          withScopes(scopes): { archiveLocation+: { http+: { auth+: { oauth2+: { scopes: if std.isArray(v=scopes) then scopes else [scopes] } } } } },
          '#withScopesMixin':: d.fn(help='\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='scopes', type=d.T.array)]),
          withScopesMixin(scopes): { archiveLocation+: { http+: { auth+: { oauth2+: { scopes+: if std.isArray(v=scopes) then scopes else [scopes] } } } } },
        },
      },
      '#withHeaders':: d.fn(help='"Headers are an optional list of headers to send with HTTP requests for artifacts"', args=[d.arg(name='headers', type=d.T.array)]),
      withHeaders(headers): { archiveLocation+: { http+: { headers: if std.isArray(v=headers) then headers else [headers] } } },
      '#withHeadersMixin':: d.fn(help='"Headers are an optional list of headers to send with HTTP requests for artifacts"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='headers', type=d.T.array)]),
      withHeadersMixin(headers): { archiveLocation+: { http+: { headers+: if std.isArray(v=headers) then headers else [headers] } } },
      '#withUrl':: d.fn(help='"URL of the artifact"', args=[d.arg(name='url', type=d.T.string)]),
      withUrl(url): { archiveLocation+: { http+: { url: url } } },
    },
    '#oss':: d.obj(help='"OSSArtifact is the location of an Alibaba Cloud OSS artifact"'),
    oss: {
      '#accessKeySecret':: d.obj(help='"SecretKeySelector selects a key of a Secret."'),
      accessKeySecret: {
        '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
        withKey(key): { archiveLocation+: { oss+: { accessKeySecret+: { key: key } } } },
        '#withName':: d.fn(help='"Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
        withName(name): { archiveLocation+: { oss+: { accessKeySecret+: { name: name } } } },
        '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
        withOptional(optional): { archiveLocation+: { oss+: { accessKeySecret+: { optional: optional } } } },
      },
      '#lifecycleRule':: d.obj(help="\"OSSLifecycleRule specifies how to manage bucket's lifecycle\""),
      lifecycleRule: {
        '#withMarkDeletionAfterDays':: d.fn(help='"MarkDeletionAfterDays is the number of days before we delete objects in the bucket"', args=[d.arg(name='markDeletionAfterDays', type=d.T.integer)]),
        withMarkDeletionAfterDays(markDeletionAfterDays): { archiveLocation+: { oss+: { lifecycleRule+: { markDeletionAfterDays: markDeletionAfterDays } } } },
        '#withMarkInfrequentAccessAfterDays':: d.fn(help='"MarkInfrequentAccessAfterDays is the number of days before we convert the objects in the bucket to Infrequent Access (IA) storage type"', args=[d.arg(name='markInfrequentAccessAfterDays', type=d.T.integer)]),
        withMarkInfrequentAccessAfterDays(markInfrequentAccessAfterDays): { archiveLocation+: { oss+: { lifecycleRule+: { markInfrequentAccessAfterDays: markInfrequentAccessAfterDays } } } },
      },
      '#secretKeySecret':: d.obj(help='"SecretKeySelector selects a key of a Secret."'),
      secretKeySecret: {
        '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
        withKey(key): { archiveLocation+: { oss+: { secretKeySecret+: { key: key } } } },
        '#withName':: d.fn(help='"Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
        withName(name): { archiveLocation+: { oss+: { secretKeySecret+: { name: name } } } },
        '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
        withOptional(optional): { archiveLocation+: { oss+: { secretKeySecret+: { optional: optional } } } },
      },
      '#withBucket':: d.fn(help='"Bucket is the name of the bucket"', args=[d.arg(name='bucket', type=d.T.string)]),
      withBucket(bucket): { archiveLocation+: { oss+: { bucket: bucket } } },
      '#withCreateBucketIfNotPresent':: d.fn(help="\"CreateBucketIfNotPresent tells the driver to attempt to create the OSS bucket for output artifacts, if it doesn't exist\"", args=[d.arg(name='createBucketIfNotPresent', type=d.T.boolean)]),
      withCreateBucketIfNotPresent(createBucketIfNotPresent): { archiveLocation+: { oss+: { createBucketIfNotPresent: createBucketIfNotPresent } } },
      '#withEndpoint':: d.fn(help='"Endpoint is the hostname of the bucket endpoint"', args=[d.arg(name='endpoint', type=d.T.string)]),
      withEndpoint(endpoint): { archiveLocation+: { oss+: { endpoint: endpoint } } },
      '#withKey':: d.fn(help='"Key is the path in the bucket where the artifact resides"', args=[d.arg(name='key', type=d.T.string)]),
      withKey(key): { archiveLocation+: { oss+: { key: key } } },
      '#withSecurityToken':: d.fn(help="\"SecurityToken is the user's temporary security token. For more details, check out: https://www.alibabacloud.com/help/doc-detail/100624.htm\"", args=[d.arg(name='securityToken', type=d.T.string)]),
      withSecurityToken(securityToken): { archiveLocation+: { oss+: { securityToken: securityToken } } },
    },
    '#raw':: d.obj(help='"RawArtifact allows raw string content to be placed as an artifact in a container"'),
    raw: {
      '#withData':: d.fn(help='"Data is the string contents of the artifact"', args=[d.arg(name='data', type=d.T.string)]),
      withData(data): { archiveLocation+: { raw+: { data: data } } },
    },
    '#s3':: d.obj(help='"S3Artifact is the location of an S3 artifact"'),
    s3: {
      '#accessKeySecret':: d.obj(help='"SecretKeySelector selects a key of a Secret."'),
      accessKeySecret: {
        '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
        withKey(key): { archiveLocation+: { s3+: { accessKeySecret+: { key: key } } } },
        '#withName':: d.fn(help='"Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
        withName(name): { archiveLocation+: { s3+: { accessKeySecret+: { name: name } } } },
        '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
        withOptional(optional): { archiveLocation+: { s3+: { accessKeySecret+: { optional: optional } } } },
      },
      '#createBucketIfNotPresent':: d.obj(help='"CreateS3BucketOptions options used to determine automatic automatic bucket-creation process"'),
      createBucketIfNotPresent: {
        '#withObjectLocking':: d.fn(help='"ObjectLocking Enable object locking"', args=[d.arg(name='objectLocking', type=d.T.boolean)]),
        withObjectLocking(objectLocking): { archiveLocation+: { s3+: { createBucketIfNotPresent+: { objectLocking: objectLocking } } } },
      },
      '#encryptionOptions':: d.obj(help='"S3EncryptionOptions used to determine encryption options during s3 operations"'),
      encryptionOptions: {
        '#serverSideCustomerKeySecret':: d.obj(help='"SecretKeySelector selects a key of a Secret."'),
        serverSideCustomerKeySecret: {
          '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
          withKey(key): { archiveLocation+: { s3+: { encryptionOptions+: { serverSideCustomerKeySecret+: { key: key } } } } },
          '#withName':: d.fn(help='"Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
          withName(name): { archiveLocation+: { s3+: { encryptionOptions+: { serverSideCustomerKeySecret+: { name: name } } } } },
          '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
          withOptional(optional): { archiveLocation+: { s3+: { encryptionOptions+: { serverSideCustomerKeySecret+: { optional: optional } } } } },
        },
        '#withEnableEncryption':: d.fn(help='"EnableEncryption tells the driver to encrypt objects if set to true. If kmsKeyId and serverSideCustomerKeySecret are not set, SSE-S3 will be used"', args=[d.arg(name='enableEncryption', type=d.T.boolean)]),
        withEnableEncryption(enableEncryption): { archiveLocation+: { s3+: { encryptionOptions+: { enableEncryption: enableEncryption } } } },
        '#withKmsEncryptionContext':: d.fn(help='"KmsEncryptionContext is a json blob that contains an encryption context. See https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#encrypt_context for more information"', args=[d.arg(name='kmsEncryptionContext', type=d.T.string)]),
        withKmsEncryptionContext(kmsEncryptionContext): { archiveLocation+: { s3+: { encryptionOptions+: { kmsEncryptionContext: kmsEncryptionContext } } } },
        '#withKmsKeyId':: d.fn(help='"KMSKeyId tells the driver to encrypt the object using the specified KMS Key."', args=[d.arg(name='kmsKeyId', type=d.T.string)]),
        withKmsKeyId(kmsKeyId): { archiveLocation+: { s3+: { encryptionOptions+: { kmsKeyId: kmsKeyId } } } },
      },
      '#secretKeySecret':: d.obj(help='"SecretKeySelector selects a key of a Secret."'),
      secretKeySecret: {
        '#withKey':: d.fn(help='"The key of the secret to select from.  Must be a valid secret key."', args=[d.arg(name='key', type=d.T.string)]),
        withKey(key): { archiveLocation+: { s3+: { secretKeySecret+: { key: key } } } },
        '#withName':: d.fn(help='"Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names"', args=[d.arg(name='name', type=d.T.string)]),
        withName(name): { archiveLocation+: { s3+: { secretKeySecret+: { name: name } } } },
        '#withOptional':: d.fn(help='"Specify whether the Secret or its key must be defined"', args=[d.arg(name='optional', type=d.T.boolean)]),
        withOptional(optional): { archiveLocation+: { s3+: { secretKeySecret+: { optional: optional } } } },
      },
      '#withBucket':: d.fn(help='"Bucket is the name of the bucket"', args=[d.arg(name='bucket', type=d.T.string)]),
      withBucket(bucket): { archiveLocation+: { s3+: { bucket: bucket } } },
      '#withEndpoint':: d.fn(help='"Endpoint is the hostname of the bucket endpoint"', args=[d.arg(name='endpoint', type=d.T.string)]),
      withEndpoint(endpoint): { archiveLocation+: { s3+: { endpoint: endpoint } } },
      '#withInsecure':: d.fn(help='"Insecure will connect to the service with TLS"', args=[d.arg(name='insecure', type=d.T.boolean)]),
      withInsecure(insecure): { archiveLocation+: { s3+: { insecure: insecure } } },
      '#withKey':: d.fn(help='"Key is the key in the bucket where the artifact resides"', args=[d.arg(name='key', type=d.T.string)]),
      withKey(key): { archiveLocation+: { s3+: { key: key } } },
      '#withRegion':: d.fn(help='"Region contains the optional bucket region"', args=[d.arg(name='region', type=d.T.string)]),
      withRegion(region): { archiveLocation+: { s3+: { region: region } } },
      '#withRoleARN':: d.fn(help='"RoleARN is the Amazon Resource Name (ARN) of the role to assume."', args=[d.arg(name='roleARN', type=d.T.string)]),
      withRoleARN(roleARN): { archiveLocation+: { s3+: { roleARN: roleARN } } },
      '#withUseSDKCreds':: d.fn(help='"UseSDKCreds tells the driver to figure out credentials based on sdk defaults."', args=[d.arg(name='useSDKCreds', type=d.T.boolean)]),
      withUseSDKCreds(useSDKCreds): { archiveLocation+: { s3+: { useSDKCreds: useSDKCreds } } },
    },
    '#withArchiveLogs':: d.fn(help='"ArchiveLogs indicates if the container logs should be archived"', args=[d.arg(name='archiveLogs', type=d.T.boolean)]),
    withArchiveLogs(archiveLogs): { archiveLocation+: { archiveLogs: archiveLogs } },
  },
  '#withArtifacts':: d.fn(help='"Artifacts maps artifact name to Artifact description"', args=[d.arg(name='artifacts', type=d.T.object)]),
  withArtifacts(artifacts): { artifacts: artifacts },
  '#withArtifactsMixin':: d.fn(help='"Artifacts maps artifact name to Artifact description"\n\n**Note:** This function appends passed data to existing values', args=[d.arg(name='artifacts', type=d.T.object)]),
  withArtifactsMixin(artifacts): { artifacts+: artifacts },
  '#mixin': 'ignore',
  mixin: self,
}
